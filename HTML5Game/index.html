<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <style>
        #canvas {
            border: 1px solid #000;
        }
    </style>
    <title>Canvas</title>
</head>
<body>
    <canvas id="canvas" width="500" height="500"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const HEIGHT = 500;
        const WIDTH = 500;
        const message = "Bouncing";
        let timeWhenGameStarted = Date.now();
        let frameCount = 0;
        let score = 0;
        ctx.font = '30px Arial';    // Setting font

        // 玩家只有一个，所以只需要一个变量
        const player = {
            x: 50,
            y: 40,
            spdX: 30,
            spdY: 5,
            name: 'P',
            hp: 10,
            width: 20,
            height: 20,
            color: 'green',
        };
        // AI有多个，需要有容器来存储它
        let enemyList = {};
        let upgradeList = {};
        let bulletList = {};
        // AI 属性
        function Enemy(id, x, y, spdX, spdY, width, height) {
            let enemy = {
                x: x,
                y: y,
                spdX: spdX,
                spdY: spdY,
                name: 'E',
                id: id,
                width: width,
                height: height,
                color: 'red',
            };
            enemyList[id] = enemy;
        }

        // 奖励
        function Upgrade(id, x, y, spdX, spdY, width, height) {
            let upgrade = {
                x: x,
                y: y,
                spdX: spdX,
                spdY: spdY,
                name: 'E',
                id: id,
                width: width,
                height: height,
                color: 'orange',
            };
            upgradeList[id] = upgrade;
        }

        // 子弹
        function Bullet(id, x, y, spdX, spdY, width, height) {
            let bullet = {
                x: x,
                y: y,
                spdX: spdX,
                spdY: spdY,
                name: 'E',
                id: id,
                width: width,
                height: height,
                color: 'black',
            };
            bulletList[id] = bullet;
        }

        // 计算两个实例之间的距离
        function getDisctanceBetweenEntity(entity1, entity2) {
            let vx = entity1.x - entity2.x;
            let vy = entity1.y - entity2.y;
            return Math.sqrt(vx*vx + vy*vy);
        }

        // 测试两个实例之间位置是否够近
        function testCollisionEntity(entity1, entity2) {
            let rect1 = {
                x: entity1.x - entity1.width/2,
                y: entity1.y - entity1.height/2,
                width: entity1.width,
                height: entity1.height,
            };
            let rect2 = {
                x: entity2.x - entity2.width/2,
                y: entity2.y - entity2.height/2,
                width: entity2.width,
                height: entity2.height,
            };
            return testCollisionRectRect(rect1, rect2);
        }

        function testCollisionRectRect(rect1, rect2) {
            return rect1.x <= rect2.x + rect2.width
                && rect2.x <= rect1.x + rect1.width
                && rect1.y <= rect2.y + rect2.height
                && rect2.y <= rect1.y + rect1.height;
        }

        // 玩家用鼠标移动来控制角色
        document.onmousemove = function(mouse) {
            let mouseX = mouse.clientX - 8;
            let mouseY = mouse.clientY - 8;

            if (mouseX < player.width/2) {
                mouseX = player.width/2;
            }
            if (mouseX > WIDTH - player.width/2) {
                mouseX = WIDTH - player.width/2;
            }
            if (mouseY < player.height/2) {
                mouseY = player.height/2;
            }
            if (mouseY > HEIGHT - player.height/2) {
                mouseY = HEIGHT - player.height/2;
            }
            player.x = mouseX;
            player.y = mouseY;
        }

        // 更行实例位置
        function updateEntityPosition(entity) {
            entity.x += entity.spdX;
            entity.y += entity.spdY;

            if (entity.x < 0 || entity.x > WIDTH) {
                entity.spdX = -entity.spdX;
            }

            if (entity.y < 0 || entity.y > HEIGHT) {
                entity.spdY = -entity.spdY;
            }
        }

        // 显示实例
        function drawEntity(entity) {
            ctx.save();
            ctx.fillStyle = entity.color;
            ctx.fillRect(entity.x - entity.width/2, entity.y - entity.height/2, entity.width, entity.height);      
            ctx.restore();
        }

        // 更新实例
        function updateEntity(entity) {
            updateEntityPosition(entity);
            drawEntity(entity);
        }

        // 随机生成AI
        function randomlyGenerateEnemy() {
            let x = Math.random() * WIDTH;
            let y = Math.random() * HEIGHT;
            let height = Math.random() * 30 + 10;
            let width = Math.random() * 30 + 10;
            let id = Math.random();
            let spdX = Math.random() * 5 + 5;
            let spdY = Math.random() * 5 + 5;
            Enemy(id, x, y, spdX, spdY, width, height);
        }

        // 随机生成奖励
        function randomlyGenerateUpgrade() {
            let x = Math.random() * WIDTH;
            let y = Math.random() * HEIGHT;
            let height = 10;
            let width = 10;
            let id = Math.random();
            let spdX = 0;
            let spdY = 0;
            Upgrade(id, x, y, spdX, spdY, width, height);
        }

        // 随机生成子弹
        function randomlyGenerateBullet() {
            let x = player.x;
            let y = player.y;
            let height = 10;
            let width = 10;
            let id = Math.random();
            // 子弹发射角度随机，角度不能用 degree 来表示，应用 rad
            let angle = Math.random() * 360;
            let spdX = Math.cos(angle/180*Math.PI) * 5;
            let spdY = Math.sin(angle/180*Math.PI) * 5;
            Bullet(id, x, y, spdX, spdY, width, height);
        }

        function startNewGame() {
            timeWhenGameStarted = Date.now();
            player.hp = 10;
            score = 0;
            frameCount = 0;
            enemyList = {};
            upgradeList = {};
            randomlyGenerateEnemy();
            randomlyGenerateEnemy();
            randomlyGenerateEnemy();
        }

        // 更新画布
        function update() {
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            score++;
            frameCount++;

            // 每4秒生成一个AI
            if (frameCount % 100 === 0) {
                randomlyGenerateEnemy();
            }

            // 每3秒生成一个奖励
            if (frameCount % 75 === 0) {
                randomlyGenerateUpgrade();
            }

            // 每1秒生成一个子弹
            if (frameCount % 25 === 0) {
                randomlyGenerateBullet();
            }

            for (let key in bulletList) {
                updateEntity(bulletList[key]);
            }

            for (let key in upgradeList) {
                updateEntity(upgradeList[key]);
                let isColliding = testCollisionEntity(player, upgradeList[key]);
                if (isColliding) {
                    score += 100;
                    delete upgradeList[key];
                }
            }

            for (let key in enemyList) {
                updateEntity(enemyList[key]);
                let isColliding = testCollisionEntity(player, enemyList[key]);

                if (isColliding) {
                    player.hp = player.hp - 1;
                    if (player.hp <= 0) {
                        let timeSurvived = Date.now() - timeWhenGameStarted;
                        console.log('You lost! You survived for ' + timeSurvived + " ms.");
                        // 游戏重新开始
                        startNewGame();
                    }
                }
            }
            drawEntity(player);
            ctx.fillText(player.hp + " Hp", 0, 30);
            ctx.fillText('Score:' + score, 200, 30);
        }

        setInterval(update, 40);
    </script>
</body>
</html>